---
title: SQCL
description: Learn how to setup SQLC with NuxtHub.
---

::callout{icon="i-simple-icons-drizzle" to="https://https://sqlc.dev/" external}
Learn more about **SQLC**.
::

## Setup

To enhance your Developer Experience with the database, we can create a `useSQLC()` server composable with few steps.

### Install SQLC

1. Install the [`sqlc` binay](https://docs.sqlc.dev/en/latest/overview/install.html).

2. Configure `sqlc.yaml`

Create a `sqlc.yaml` configuration file at the root of your project. This will tell sqlc how to generate TypeScript code from your SQL files.

Example `sqlc.yaml` configuration:

```yaml
# sqlc.yaml
version: '2'
plugins:
- name: ts
  wasm:
    url: https://downloads.sqlc.dev/plugin/sqlc-gen-typescript_0.1.3.wasm
    sha256: 287df8f6cc06377d67ad5ba02c9e0f00c585509881434d15ea8bd9fc751a9368
sql:
- schema: "server/database/schema.sql"
  queries: "server/database/query.sql"
  engine: sqlite
  codegen:
  - out: "server/database/generated.ts"
    plugin: ts
    options:
      runtime: node
      driver: d1
```

In this configuration:

- The `server/database/schema.sql` file defines your database schema.
- The queries file your SQL queries. You can also use a folder if you prefer.
- The generated Go code will be in `internal/db`, and the TypeScript code will be in `server/database/generated.ts`.

### Database Schema

In `server/database/schema.sql`, define the schema for your database. For example, for a `users` table:

```sql [server/database/schema.sql]
CREATE TABLE users (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  name TEXT NOT NULL,
  email TEXT NOT NULL UNIQUE,
  password TEXT NOT NULL,
  avatar TEXT NOT NULL,
  created_at TIMESTAMP NOT NULL
);
```

### Write SQL Queries

In the `server/database/queries.ts` file, create a file with your queries:

```sql [server/database/queries.ts]
-- name: getUserById :one
SELECT id, name, email, avatar, created_at FROM users WHERE id = ?;

-- name: listUsers :many
SELECT id, name, email, avatar, created_at FROM users;

-- name: createUser :one
INSERT INTO users (name, email, password, avatar, created_at) 
VALUES (?, ?, ?, ?, ?);

-- name: updateUser :one
UPDATE users SET name = $1, email = $2, avatar = $3 WHERE id = $4;

-- name: updateUser :one
UPDATE users SET name = $1, email = $2, avatar = $3 WHERE id = $4;
```

::note
For every statement in your queries make sure to follow [`qslc`'s special syntax](https://docs.sqlc.dev/en/latest/reference/query-annotations.html) to define the queries. 
::

### `npm run db:generate`

Run sqlc to generate the TypeScript code from the SQL schema and queries:

```json [package.json]
{
  "scripts": {
    "db:generate": "sqlc generate"
  }
}
```

When running the `npm run db:generate` command, `sqlc` will generate the migrations based on `server/database/schema.ts` and save them in the `server/database/generated.ts` file.

To apply the changes in staging or production, you can run the server using `npx nuxi dev --remote` command to connect your local server to the remote database, learn more about [remote storage](/docs/getting-started/remote-storage).

::note
We are planning to update this section to leverage [Nitro Tasks](https://nitro.unjs.io/guide/tasks) instead of a server plugin in the future.
::

### `useSqlc()`

Lastly, we can create a `useSqlc()` server composable to interact with the database:

```ts [server/utils/sqlc.ts]
import { createPool } from 'better3-sqlite';
import { db } from './db';
import { User } from './types';

// Create a connection pool to your SQLite database
const pool = createPool('server/database/database.sqlite');

// Export the useSqlc function to use in API handlers
export const useSqlc = () => {
  return db.queries(pool);
};

// Export the User type and utility functions
export { User };
```

We are exporting the `tables` object and the `useSqlc` function to be used in our API handlers without having to import them (Nuxt does it for us as long as it's exported from a `server/utils/` file).

::callout
Note that we are also exporting the `User` type, which is created by `sqlc`. This is useful for type-checking the results of your queries.
::

### Seed the database (Optional)

You can add a server task to populate your database with initial data. This uses [Nitro Tasks](https://nitro.unjs.io/guide/tasks), which is currently an experimental feature.

1. Update your nuxt.config.js:

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  nitro: {
    experimental: {
      tasks: true
    }
  }
})
```

2. Create a new file containing the task:

```ts [server/tasks/seed.ts]
export default defineTask({
  meta: {
    name: 'db:seed',
    description: 'Run database seed task'
  },
  async run() {
    console.log('Running DB seed task...')
    const users = [
      {
        name: 'John Doe',
        email: 'john@example.com',
        password: 'password123',
        avatar: 'https://example.com/avatar/john.png',
        createdAt: new Date()
      },
      {
        name: 'Jane Doe',
        email: 'jane@example.com',
        password: 'password123',
        avatar: 'https://example.com/avatar/jane.png',
        createdAt: new Date()
      }
    ]
    await useSqlc().insertUsers(users)
    return { result: 'success' }
  }
})
```

To run the seed task, start your dev server and open the Nuxt DevTools. Go to _Tasks_ and you will see the `db:seed` task ready to run. This will add the seed data to your database and give you the first users to work with.

## Usage

### Select

```ts [server/api/users/index.get.ts]
export default eventHandler(async () => {
  const users = await useSqlc().listUsers()

  return users
})
```

### Insert

```ts [server/api/users/index.post.ts]
export default eventHandler(async (event) => {
  const { name, email, password, avatar } = await readBody(event)

  const ueer = await useSqlc().createUser(name, email, password, avatar, new Date())
  return user
})
```

### Update

```ts [server/api/user/[id\\].patch.ts]
export default eventHandler(async (event) => {
  const { id } = getRouterParams(event)
  const { name, email, avatar } = await readBody(event)

  const user = await useSqlc().updateUser(name, email, avatar, id)
  return user
})

```

### Delete

```ts [server/api/user/[id\\].delete.ts]
export default eventHandler(async (event) => {
  const { id } = getRouterParams(event)
  const db = useSqlc()

  const deletedUser = await db.deleteUser(id)

  if (!deletedUser) {
    throw createError({
      statusCode: 404,
      message: 'User not found'
    })
  }
  return deletedUser
})
```
